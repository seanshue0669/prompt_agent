# agents/orchestrator/schema.py
from typing import TypedDict, List
from agentcore import BaseSchema 

# ========================================================
# State definition
# ========================================================
class OrchestratorState(TypedDict):
    """
    State for Orchestrator (Top Controller).
    
    Manages the overall flow across 6 diagnostic stages.
    Each stage goes through: Diagnostic â†’ Questioning â†’ Integration
    
    Fields:
        current_prompt: Current version of the prompt (updated after each stage)
        system_prompt: System prompt injected by Orchestrator for current agent
        question_list: Questions generated by DiagnosticAgent
        answer_list: Answers collected by QuestioningAgent
        stage_idx: Current stage number (1-6)
        dialogue_idx: Current question index within a stage
        followup_count: Current followup count for the current question
    """
    current_prompt: str
    system_prompt: str
    question_list: List[str]
    answer_list: List[str]
    stage_idx: int
    dialogue_idx: int
    followup_count: int

# ========================================================
# Node definitions
# ========================================================
def init_stage(state: OrchestratorState) -> dict:
    """
    Initialize a new diagnostic stage.
    Resets answer_list, question_list, dialogue_idx, followup_count.
    Injects appropriate system_prompt based on stage_idx.
    """
    return state

def call_diagnostic(state: OrchestratorState) -> dict:
    """
    Call DiagnosticAgent subgraph to generate questions.
    """
    return state

def call_questioning(state: OrchestratorState) -> dict:
    """
    Call QuestioningAgent subgraph to ask questions and collect answers.
    """
    return state

def call_integration(state: OrchestratorState) -> dict:
    """
    Call IntegrationAgent subgraph to integrate answers into prompt.
    """
    return state

def update_stage(state: OrchestratorState) -> dict:
    """
    Update stage_idx to move to next stage.
    """
    return state

# ========================================================
# Edge definitions
# ========================================================
def route_after_questioning(state: OrchestratorState) -> str:
    """
    Route after QuestioningAgent based on dialogue progress.
    
    Returns:
        "call_questioning": If more questions remain
        "call_integration": If all questions answered
    """
    return "call_integration"

def route_after_integration(state: OrchestratorState) -> str:
    """
    Route after IntegrationAgent based on stage progress.
    
    Returns:
        "init_stage": If more stages remain (stage_idx < 6)
        "end": If all 6 stages completed
    """
    return "end"

# ========================================================
# Schema Definition
# ========================================================
class OrchestratorSchema(BaseSchema):
    state_type = OrchestratorState

    # No state_mapping needed (Orchestrator is top-level)
    state_mapping = {}

    nodes = [
        ("init_stage", init_stage),
        ("call_diagnostic", call_diagnostic),
        ("call_questioning", call_questioning),
        ("call_integration", call_integration),
        ("update_stage", update_stage)
    ]
    
    conditional_edges = [
        ("call_questioning", route_after_questioning, {
            "call_questioning": "call_questioning",
            "call_integration": "call_integration"
        }),
        ("update_stage", route_after_integration, {
            "init_stage": "init_stage",
            "end": "end"
        })
    ]
    
    direct_edges = [
        ("init_stage", "call_diagnostic"),
        ("call_diagnostic", "call_questioning"),
        ("call_integration", "update_stage")
    ]